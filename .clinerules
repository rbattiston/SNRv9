# SNRv9 Project Intelligence - .clinerules

## Critical Implementation Paths

### ESP32 Stack Requirements
**Key Learning**: ESP32 tasks require minimum 2048 bytes stack for reliable operation
- **Context**: Initial demo tasks with 1536/1024 bytes caused stack overflow crashes
- **Solution**: Always use 2048+ bytes for application tasks
- **Monitoring**: Implement stack usage warnings at 70%, 80%, 90% thresholds
- **Critical**: Stack overflow prevention is essential for system stability

### Memory Monitoring Architecture
**Pattern**: Centralized monitoring with thread-safe data collection
- **Implementation**: Separate monitoring modules (memory_monitor, task_tracker)
- **Thread Safety**: Always use FreeRTOS mutexes with 100ms timeout
- **Performance**: Keep monitoring overhead <1% CPU usage
- **Reporting**: Multiple intervals - memory (30s), tasks (10s), stack warnings (5s)

### Debug Configuration Strategy
**Pattern**: Compile-time configurable debug output via centralized header
- **File**: `include/debug_config.h` - single point of control
- **Production Safety**: Zero performance impact when disabled
- **Flexibility**: Individual enable/disable for each monitoring system
- **Timestamps**: Configurable timestamp support for debug correlation

## User Preferences and Workflow

### Development Approach
- **Incremental Development**: Build and test each component thoroughly before proceeding
- **Comprehensive Monitoring**: Implement monitoring for every system component
- **Proactive Issue Detection**: Early warning systems prevent failures
- **Documentation First**: Memory bank documentation maintained alongside code

### Code Quality Standards
- **Naming Convention**: snake_case for functions and variables
- **Documentation**: Doxygen-style comments for all public functions
- **Error Handling**: Consistent error checking and graceful degradation
- **Thread Safety**: Mutex protection for all shared data structures

### Testing Philosophy
- **Extended Operation**: Minimum 1-hour continuous operation testing
- **Resource Monitoring**: Continuous tracking of memory and stack usage
- **Failure Prevention**: Focus on preventing issues rather than recovering from them
- **Real Hardware**: Always test on actual ESP32 hardware, not simulation

## Project-Specific Patterns

### ESP-IDF/FreeRTOS Integration
**Key Patterns**:
- Use `esp_timer_get_time()` for high-resolution timestamps
- Leverage `uxTaskGetSystemState()` for comprehensive task information
- Implement proper task priority hierarchy (monitoring tasks at low priority)
- Use `pvPortMalloc/vPortFree` for FreeRTOS-aware memory allocation

### Memory Management Strategy
**Approach**: Monitor but don't interfere with normal allocation
- **Heap Tracking**: Periodic sampling of `esp_get_free_heap_size()`
- **Leak Detection**: Trend analysis over time rather than absolute thresholds
- **Fragmentation**: Monitor largest free block vs total free memory
- **Safety**: Never allocate memory in monitoring code paths

### Task Architecture
**Design Pattern**: Layered task structure
```
High Priority (24): IPC tasks (system)
Medium Priority (2-3): Application tasks (irrigation control)
Low Priority (1): Monitoring tasks (memory, task tracking)
Idle Priority (0): IDLE tasks (system)
```

## Known Challenges and Solutions

### Stack Overflow Prevention
**Challenge**: ESP32 stack requirements higher than expected
**Solution**: 
- Minimum 2048 bytes for application tasks
- Multi-level warning system (70%, 80%, 90%)
- Continuous monitoring every 5 seconds
- Proactive alerts before overflow conditions

### System Controller Memory Access Violations (January 28, 2025)
**Challenge**: Critical crashes when accessing WiFi handler functions from system controller
**Root Cause**: Memory access violations in `wifi_handler_is_connected()` calls
**Symptoms**: System crashes/reboots when accessing `/api/system/status` endpoints
**Solution**:
- Temporarily disabled all `wifi_handler_is_connected()` calls in system controller
- Replaced WiFi status with safe placeholder data
- Maintained API structure for future re-integration
- System controller now stable with all endpoints functional
**Lesson**: External function calls in web handlers require careful memory safety validation
**Future**: WiFi integration to be re-enabled with proper safety checks

### Thread Safety in Monitoring
**Challenge**: Multiple tasks accessing shared monitoring data
**Solution**:
- FreeRTOS mutexes with timeout (100ms)
- Atomic operations where possible
- Separate data collection and reporting phases
- Graceful degradation if mutex acquisition fails

### Production vs Development Configuration
**Challenge**: Debug output needed for development but not production
**Solution**:
- Compile-time flags in centralized header
- Macro-based debug output system
- Zero performance impact when disabled
- Easy toggle between development and production builds

## Evolution of Project Decisions

### Web Server Architecture Decision (January 28, 2025)
**Initial Plan**: ESPAsyncWebServer (third-party library)
**Final Decision**: ESP-IDF HTTP Server (official Espressif component)
**Rationale**: 
- Official support and long-term maintenance from Espressif
- Better integration with ESP-IDF ecosystem and event system
- Comprehensive documentation and proven reliability in production
- Native WebSocket support and advanced HTTP features
- Alignment with ESP-IDF best practices and examples
**Impact**: Complete revision of Step 2 implementation approach in webServerImplementationPlan.md

### Initial Approach vs Current Implementation
**Initial**: Simple printf debugging
**Current**: Comprehensive monitoring system with configurable output
**Reason**: Need for production-ready debugging and system visibility

**Initial**: Basic task creation without monitoring
**Current**: Full task lifecycle tracking with early warning systems
**Reason**: Stack overflow issues required proactive monitoring

**Initial**: Scattered debug configuration
**Current**: Centralized configuration in `debug_config.h`
**Reason**: Maintainability and production deployment requirements

### Architecture Evolution
**Phase 1**: Basic ESP32 project structure
**Phase 2**: Added memory monitoring system
**Phase 3**: Added task tracking system
**Phase 4**: Integrated early warning systems
**Phase 5**: Demo task removal and production preparation
**Current**: Clean foundation optimized for irrigation control implementation

## Tool Usage Patterns

### PlatformIO Workflow
- Use `pio run` for building (checks compilation)
- Use `pio run --target upload` for deployment
- Use `pio device monitor` for serial debugging
- Monitor build warnings (especially memory size mismatches)

### Development Cycle
1. Implement feature with comprehensive error checking
2. Build and verify compilation
3. Upload to hardware and test
4. Monitor serial output for issues
5. Run extended operation test (minimum 1 hour)
6. Update memory bank documentation
7. Commit changes with descriptive messages

### Debugging Strategy
- Enable all monitoring systems during development
- Use timestamped debug output for correlation
- Monitor stack usage continuously during testing
- Check for memory leaks over extended operation
- Verify thread safety under load conditions

## Recent Milestones

### Demo Task Removal (January 28, 2025)
**Achievement**: Successfully transitioned from demo/testing phase to production-ready foundation
**Key Changes**:
- Removed all demo tasks from main.c (3 tasks eliminated)
- Simplified main application loop for irrigation control focus
- Adjusted monitoring frequency to production levels (5-minute health checks)
- Optimized memory usage (Flash: 19.3% → 19.2%, Task count: 8 → 5)
- Maintained all monitoring systems for production reliability

**Lessons Learned**:
- Demo tasks served their purpose for validating monitoring systems
- Clean removal process validates modular architecture design
- Production monitoring frequency reduces overhead while maintaining safety
- System foundation is robust enough for real application development

### Component Filesystem Reorganization (January 30, 2025)
**Achievement**: Complete ESP-IDF component-based architecture implementation
**Key Changes**:
- Migrated all source files from flat `src/` and `include/` structure to component-based organization
- Created 4 components: core, network, storage, web with proper dependency hierarchy
- Resolved debug_config.h conflicts through component-local copies
- Established proper CMakeLists.txt configuration for each component
- Maintained 100% compilation success throughout migration process

**Critical Technical Patterns Discovered**:
- **Component Dependency Resolution**: ESP-IDF REQUIRES declarations must match actual dependencies
- **Include Path Management**: Component-local copies of shared headers prevent cross-component conflicts
- **Build System Integration**: Each component needs proper CMakeLists.txt with SRCS, INCLUDE_DIRS, REQUIRES
- **Incremental Migration**: Test compilation after each file move to catch issues immediately
- **Debug Header Strategy**: Duplicate debug_config.h in each component simpler than complex include paths

**Lessons Learned**:
- **Compilation Testing Critical**: Test build after every file move prevents accumulating errors
- **Component Boundaries**: Clear separation of concerns makes system more maintainable
- **ESP-IDF Best Practices**: Following official component architecture pays dividends
- **Include Path Complexity**: Simple solutions (file copies) often better than complex include hierarchies
- **Dependency Management**: Explicit dependency declarations prevent circular dependencies

**Quality Validation**:
- Zero compilation errors after reorganization
- Memory usage unchanged: RAM: 14.4%, Flash: 34.7%
- All monitoring systems continue to function correctly
- Component boundaries respect single responsibility principle
- Future development can proceed with confidence in modular architecture

### Step 3: Static File Controller with Advanced Caching (January 28, 2025)
**Achievement**: Production-grade HTTP caching system exceeding original requirements
**Key Implementation**:
- Advanced ETag generation using FNV-1a hash algorithm
- Conditional requests with 304 Not Modified responses
- File-type specific cache policies (CSS: 24hrs, Images: 7 days, Fonts: 30 days)
- Thread-safe cache management with mutex protection
- Real-world browser cache integration verified

**Critical Technical Patterns**:
- **ETag Generation**: `static_file_controller_generate_etag()` using content hash
- **Conditional Requests**: `static_file_controller_check_etag_match()` for If-None-Match headers
- **MIME Type Optimization**: Comprehensive mapping with cache and compression settings
- **Thread Safety**: Mutex-protected cache operations with 100ms timeout
- **Performance Validation**: Browser network tab analysis for cache effectiveness

**Real-World Validation**:
- Browser shows "(memory cache)" for CSS files with 0ms load time
- ETag headers properly generated and validated
- Cache hit/miss statistics tracking functional
- Production-grade performance under real browser conditions

**Lessons Learned**:
- Browser cache integration requires proper HTTP headers, not just server-side caching
- ETag generation must be deterministic and content-based for reliability
- File-type specific cache policies dramatically improve user experience
- Real-world testing with browser developer tools is essential for validation
- Thread-safe design prevents cache corruption under concurrent access

## Critical Success Factors

### System Reliability
- Zero tolerance for crashes or reboots
- Proactive issue detection before failures
- Comprehensive resource monitoring
- Graceful degradation on component failures

### Development Efficiency
- Centralized configuration management
- Comprehensive diagnostic information
- Clear separation between development and production builds
- Maintainable code structure with good documentation

### Commercial Readiness
- Production-safe debug output control
- Reliable operation under all conditions
- Comprehensive monitoring for maintenance
- Scalable architecture for future features

This project demonstrates the importance of building robust monitoring and diagnostic systems early in embedded development. The investment in comprehensive monitoring pays dividends in system reliability and development efficiency.
